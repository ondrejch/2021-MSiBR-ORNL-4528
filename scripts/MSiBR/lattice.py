#!/usr/bin/env python3
#
# Lattice: Script containing a function to write a hexagonal SERPENT lattice for the MSR project.

import math
from math import ceil, sqrt, pi


def write_lattice(rmax=100, pitch=11.5, core=200, nlat='1',
                  ub='1', uf='2', uc='3',
                  nf=6, nb=1, controlRodsU=None, controlRods=None):
    '''Function to write the hexagonal lattice of the given type
	Accepts as input: these are old
		nlat:		number identifying the lattice
		ub, uf, uc:	the universe numbers of the cells for the MSR core:
					blanket, fuel, central (int);
		nf, nb:		the number of fuel/blanket cells in radius (integer);
		p:			the pitch (cm) between cells (float)
	Outputs:
		lattice:	string containing the generated lattice card'''

    # Structure of a SERPENT lattice card
    print('controlRod', controlRods)
    controlRodsU = None
    ConRod = None
    if controlRodsU is None:
        controlRodsU = [51, 52, 53, 54]
    if controlRods is None or controlRods is False:
        ConRod = [{'Center': False, 'NE': False, 'SE': False, 'SW': False, 'NW': False},
                  {'Center': False, 'NE': False, 'SE': False, 'SW': False, 'NW': False}]
    if controlRods is True:
        ConRod = [{'Center': True, 'NE': True, 'SE': True, 'SW': True, 'NW': True},
                  {'Center': True, 'NE': True, 'SE': True, 'SW': True, 'NW': True}]
    print(ConRod)
    centralRods = ConRod[0]
    outerRods = ConRod[1]
    '''lat <u0> <type> <x0> <y0> <nx> <ny> <p>
	#
	# <u0> is the universe number of the lattice
	# <type> is the lattice type: 2 is our hexagon (hexyc)
	# <x0>, <y0> are the x/y coords of the origin--ours are (0,0)
	# <nx>, <ny> are the number of lattice elements in each direction
	# <p> is the lattice pitch'''

    # lattice calculation

    ''' lattice dependencies:
	pitch
	rmax
	core
	'''
    DEBUG = False
    # adjust universe numbers to include a space
    ub = str(ub) + ' '
    uf = str(uf) + ' '
    uc = str(uc) + ' '
    ucNone = str(controlRodsU[0]) + ' '
    ucCentral = str(controlRodsU[1]) + ' '
    ucOuter = str(controlRodsU[2]) + ' '
    ucCentralOuter = str(controlRodsU[3]) + ' '

    # and these go in a x type hex lattice
    n = 2 * int(ceil(core / pitch)) + 10
    n += 1 if n % 2 == 0 else 0  # make sure it is an odd pin num to center it

    lattice = '''
% This lattice was generated by a script.
lat {nlat} 2  0.0 0.0  {n} {n}  {pitch} \n'''

    # iterate through lattice positions, only place pins where they lie fully in-mod
    # lattice starts at bottom left
    x0 = 0.0
    y0 = 0.0

    x0 -= (n + 0.5 * n) * pitch / 2.0 - .75 * pitch
    y0 -= n * sqrt(3.0) / 4.0 * pitch - sqrt(3.0) / 4.0 * pitch
    value_x = 28
    value_y = 24.248711305964264

    for i in range(n):  # y positions
        thisline = ''  # lattice line in input file
        thisline += ' ' * i  # indent to show hex better
        for j in range(n):  # x positions
            y = y0 + i * sqrt(3.0) / 2.0 * pitch  # y pos
            x = x0 + (j + 0.5 * i) * pitch  # x pos
            lat_r = sqrt(x ** 2 + y ** 2)  # radius from lattice center
            if DEBUG:
                print(x, y, lat_r, lat_r < rmax)
            if lat_r < rmax:
                # if lattice radius is in the center, write the unique central channel
                if int(x) == 0 and int(y) == 0:
                    location = 'Center'
                    if centralRods[location] is False and outerRods[location] is False:
                        thisline += ucNone
                    elif centralRods[location] is True and outerRods[location] is False:
                        thisline += ucCentral
                    elif centralRods[location] is False and outerRods[location] is True:
                        thisline += ucOuter
                    elif centralRods[location] is True and outerRods[location] is True:
                        thisline += ucCentralOuter
                    else:
                        thisline += uf
                elif abs(int(x)) == int(value_x) and abs(int(y)) == int(value_y):
                    location = None
                    if int(x) > 0 and int(y) > 0:
                        location = 'NE'
                    elif int(x) > 0 and int(y) < 0:
                        location = 'SE'
                    elif int(x) < 0 and int(y) < 0:
                        location = 'SW'
                    elif int(x) < 0 and int(y) > 0:
                        location = 'NW'

                    if centralRods[location] is False and outerRods[location] is False:
                        thisline += ucNone
                    elif centralRods[location] is True and outerRods[location] is False:
                        thisline += ucCentral
                    elif centralRods[location] is False and outerRods[location] is True:
                        thisline += ucOuter
                    elif centralRods[location] is True and outerRods[location] is True:
                        thisline += ucCentralOuter
                    else:
                        thisline += uf

                else:
                    thisline += uf  # add a fuel channel to geometry
            elif lat_r < core:
                thisline += ub  # add a blank
            else:
                thisline += ub  # universe 7 is a blank blanket
        thisline += '\n'
        lattice += thisline

    lattice = lattice.format(**locals())
    return lattice


# This executes if someone tries to run the module
if __name__ == '__main__':
    print("This is a module which generates lattice cards for Serpent.")
    a = input("Press 'enter' to exit, or type anything to run a test. ")
    if a:
        print('_____________________________\n')
        print(write_lattice())
